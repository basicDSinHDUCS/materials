## 递推

递推指的是有已知的一个或几个数据，根据某种法则，推导出后续结果。

举个例子：

斐波那契数列：定义斐波那契数列为 $f(x)=f(x-1)+f(x-2) $ ,$(x>=2)$,$f(0)=f(1)=1$

所以只要我们已知 $f(0),f(1)$,我们就可以根据这个法则求出 $f(x)$ 了。

code:

```java
public static int[] fab(int x)
    {
        int[] f = new int[x+1];
        f[0]=f[1]=1;
        for(int i=2;i<=x;i++)
        {
            f[i]=f[i-1]+f[i-2];
        }
        return f;
    }
```

这是一个求出 0~n 所有值的函数。

**思考：**

很明显，我们这里开了一个数组来存放，如果我只需要求出 $f(n)$ ,是否可以将数组优化掉呢？





```java
public static int fab(int x)
    {
        int a,b,c;
        a = b = 1;
        c = a + b;
        for(int i=2;i<=x;i++)
        {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
```

**思考:**

如何用递归处理？









```java
public static int fab(int x)
    {
        if( x==0 || x==1 ) return 1;
        else return fab(x-1) + fab(x-2);
    }
```









**思考**（选做）

这两种方法谁快（运算少）？怎么优化差的一个，让他更快？



显然，对于递归的算法，我们重复计算了很多次，比如 $f(10) = f(9) + f(8),f(9)=f(8)+f(7)$ ,其中 $f(8)$ 是不是被多算了几次？当 $n$ 足够大时，这样的重复就会很致命。

所以有**记忆化**

我们用数组直接记下 $f(x)$，这样如果已经算过的话，直接跳过即可。（空间换时间）



```java
    private static int[] f;
    public static int start_fab(int x)
    {
        f =new int[x+1];
        f[0]=f[1]=1;
        return fab(x);
    }
    public static int fab(int x)
    {
        if(f[x] != 0) return f[x];
        int now = fab(x - 1)+ fab(x - 2);
        f[x] = now;
        return now;
    }
```

